<html><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><title>CIlib</title><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="Verifiable Computational Intelligence" /><meta name="author" content="net.cilib" /><meta name="og:image" content="/cilib/img/poster.png" /><meta name="og:title" content="CIlib" /><meta name="og:site_name" content="CIlib" /><meta name="og:url" content="http://cirg-up.github.io" /><meta name="og:type" content="website" /><meta name="og:description" content="Verifiable Computational Intelligence" /><meta name="twitter:image" content="/cilib/img/poster.png" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:site" content="" /><link rel="icon" type="image/png" href="/cilib/img/favicon.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cilib/highlight/styles/default.css" /><link rel="stylesheet" href="/cilib/css/style.css" /><link rel="stylesheet" href="/cilib/css/palette.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/cilib/" class="brand"><div class="brand-wrapper" style="background:url('/cilib/img/sidebar_brand.png') no-repeat"><span>CIlib</span></div></a></li> <li><a href="/cilib/docs/index.html" class="">Getting Started</a></li> <li><a href="/cilib/docs/design/index.html" class="">Design</a> <ul class="sub_section"> <li><a href="/cilib/docs/design/rvar.html" class="">RVar</a></li></ul></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li class="hidden-xs"><a href="https://github.com/cirg-up/cilib"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li class="hidden-xs"><a href="https://github.com/cirg-up/cilib"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('CIlib Verifiable Computational Intelligence');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('CIlib Verifiable Computational Intelligence');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="cirg-up" data-github-repo="cilib"><div class="content-wrapper"><section><h1 id="lenses">Lenses</h1>

<p>A <code class="highlighter-rouge">Lens</code> can, in the most trivial of ways, be seen as a getter and setter function pair.
Within CIlib, several common lenses are available to the user in order to extract information from the state
of the <code class="highlighter-rouge">Entity</code>, or anything else for which a <code class="highlighter-rouge">Lens</code> has been defined. Because lenses allow the user
to zoom onto data, potentially nested under many levels in another data structure, they are convenient
as they allow for correctly updating the “zoomed” location. When we use “correctly”, it is because with
immutable data structures, updates to values deep within a data structure need to correctly “bubble out”, such
that the entire structure is correctly updated to ensure that the data structure remains immutable and consistent.</p>

<p>In order to not re-invent the wheel, the <code class="highlighter-rouge">Monocle &lt;http://julien-truffaut.github.io/Monocle/&gt;</code>_ library
provides the lens functionality. Lenses are structures that can also be composed together and are
collectively called “optics”. Please refer to Monocle’s documentation to learn more about
lenses and optics. CIlib specific lens questions can be directed to the different CIlib support channels.</p>

<p>Lenses provide an API that is first and foremost, composition and lawful. This means that the various
optics are well behaved and rules exist that govern their usage. Furthermore, different optics may be
composed together to create new optics that are the combination of the original optics. This is obviously
only possible if the provided types correctly line up.</p>

<p>Building on the usage of optics in general, we use a mechanism known as “classy lens” in Haskell. This
mechanism prevents invalid usage, by letting the compiler fail based on the types being used.
In the case of <code class="highlighter-rouge">Entity</code>, the compiler would look up instances, using it’s implicit resolution rules, to obtain
evidence for a typeclass with a given set of types, at compile time.</p>

<p>This provides an additional level of surety that the data being passed to a function that expects a parameter
that has the evidence to extract some other piece of information for a given type.
This may seem quite like a mouth full, but let’s have a look a few examples that will hopefully make the usage clear.</p>

<p>Based on the normally accepted usage of “classy lenses”, the typeclasses that expose lenses are generally
prefixed with <code class="highlighter-rouge">Has</code>. A simple example of this would be the <code class="highlighter-rouge">HasMemory</code> typeclass.
The typeclass definition is simply: ::</p>

<p>trait HasMemory[S,A] {
    def _memory: Lens[S, Position[A]]
  }</p>

<p><code class="highlighter-rouge">HasMemory</code> defines a lens, with the name <code class="highlighter-rouge">_memory</code> that can, from a given <code class="highlighter-rouge">S</code> provide a <code class="highlighter-rouge">Position[A]</code>.
There is absolutely no mention of what <code class="highlighter-rouge">S</code> is, or should be, but the typeclass allows for a set of
instances that can actually provide this result. For example, in the context of the GA, Individuals are
entities that <em>do not</em> maintain a memory; whereas in the PSO, Particles do maintain a memory of their
previous best position (where <code class="highlighter-rouge">Position[A]</code> is a candidate solution of the problem space).</p>

<p>Within the definitions of CIlib, an Individual is nothing more than a <code class="highlighter-rouge">Entity[Unit,A]</code> for some
type <code class="highlighter-rouge">A</code>. As the type states, there is no state value for the <code class="highlighter-rouge">Entity</code>, and it is defined to
be <code class="highlighter-rouge">Unit</code> - a type that exists with a single value (expressed as <code class="highlighter-rouge">()</code>), which is uninteresting.</p>

<p>Using this definition, the following function would accept Particle entities, but would fail
to compile (due to missing evidence) if an Individual entity is passed to it: ::</p>

<p>def foo<a href="xs: List[Entity[S,Double]]">S</a>(implicit mem: HasMemory[S,Double]) = …</p>

<p>If the function <code class="highlighter-rouge">foo</code> did not have the implicit constraint defined, both a list of particle or individual
entities would be accepted. Within the <code class="highlighter-rouge">core</code> module, several basic optics (focusing on <code class="highlighter-rouge">Entity</code>)
are available for use.</p>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/cilib/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script src="/cilib/js/main.js"></script></body></html>